<!DOCTYPE html>
<html lang="pt-PT" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Missão Astro Pi: Velocidade por Imagem</title>
    <!-- Carregar Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carregar Highlight.js para realce de sintaxe -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
      /* Tipografia Inter */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap");
      body {
        font-family: "Inter", sans-serif;
      }
      .code-block {
        background-color: #1e293b;
        padding: 1.5rem;
        border-radius: 0.75rem;
        overflow-x: auto;
      }
      /* Efeito Spoiler */
      .spoiler {
        filter: blur(6px);
        cursor: pointer;
        transition: filter 0.3s ease;
        user-select: none;
      }
      .spoiler:hover {
        filter: blur(3px);
      }
      .spoiler.revealed {
        filter: blur(0);
        cursor: text;
        user-select: text;
      }
    </style>
    <script>
      tailwind.config = { darkMode: "class" };
    </script>
  </head>
  <body
    class="bg-slate-900 text-slate-300 leading-relaxed p-6 md:p-12 max-w-5xl mx-auto"
  >
    <!-- Cabeçalho -->
    <header class="mb-12 text-center">
      <h1
        class="text-4xl md:text-6xl font-black text-white mb-4 tracking-tight"
      >
        Missão Velocidade
        <span
          class="text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-violet-500"
          >Visual</span
        >
      </h1>
      <p class="text-xl text-slate-400">
        Como usar visão computacional para medir a velocidade da ISS.
      </p>
    </header>

    <!-- Introdução Teórica -->
    <section class="mb-12 bg-slate-800 p-8 rounded-2xl border border-slate-700">
      <h2 class="text-3xl font-bold text-white mb-4">
        1. A Ideia (O "Plano B")
      </h2>
      <p class="text-lg mb-4">
        O GPS é fácil. Mas a verdadeira engenharia é usar as câmaras. A ideia é
        simples:
      </p>

      <div class="grid md:grid-cols-2 gap-8 items-center">
        <div>
          <ol class="list-decimal list-inside space-y-3 text-lg">
            <li>Tiramos uma <strong>Foto A</strong>.</li>
            <li>Esperamos alguns segundos.</li>
            <li>Tiramos uma <strong>Foto B</strong>.</li>
            <li>Procuramos um ponto igual nas duas (uma ilha, um rio).</li>
            <li>
              Medimos quantos <strong>píxeis</strong> esse ponto se moveu.
            </li>
          </ol>
        </div>

        <div
          class="bg-slate-900 p-4 rounded-xl border border-slate-600 text-center"
        >
          <p class="text-sm mt-2 text-slate-500">
            Se o ponto se moveu 500 píxeis, quanto é que isso é em km?
          </p>
        </div>
      </div>

      <div
        class="mt-8 p-4 bg-violet-900/20 border border-violet-500/50 rounded-lg"
      >
        <h3 class="text-xl font-bold text-violet-300 mb-2">
          O Segredo: GSD (Ground Sampling Distance)
        </h3>
        <p>
          Para converter píxeis em km, precisamos do GSD. O GSD diz-nos:
          <strong>"1 píxel nesta imagem = X quilómetros no chão".</strong>
        </p>
        <p class="mt-2">
          Para a câmara da ISS, a uma altitude média, o GSD é aproximadamente
          <strong>12648 cm/píxel</strong> (ou 0.126 km/píxel).
        </p>
      </div>
    </section>

    <!-- O Código Base -->
    <section class="mb-12">
      <h2
        class="text-3xl font-bold text-white mb-6 border-b border-slate-700 pb-2"
      >
        2. O Nosso Código Base
      </h2>
      <p class="mb-4">
        Este código usa a biblioteca
        <code class="text-pink-400">opencv</code> (cv2) para fazer a parte
        difícil: encontrar os pontos iguais nas duas fotos.
      </p>
      <p class="mb-6 text-yellow-400 font-bold">
        ⚠️ IMPORTANTE: Este código deve ser copiado e colado no Astro Pi Replay
        Tool Online!
      </p>

      <div class="code-block">
        <pre><code class="python">
# --- CÓDIGO BASE DA MISSÃO (main.py) ---
from picamzero import Camera
from time import sleep
from exif import Image
from datetime import datetime
import cv2
import math

# --- Funções de Visão Computacional (A "Caixa Negra") ---
# (Estas funções fazem a magia de encontrar pontos iguais)

def convert_to_cv(image_1, image_2):
    img1_cv = cv2.imread(image_1, 0)
    img2_cv = cv2.imread(image_2, 0)
    return img1_cv, img2_cv

def calculate_features(img1, img2, feature_number=1000):
    orb = cv2.ORB_create(nfeatures=feature_number)
    kp1, des1 = orb.detectAndCompute(img1, None)
    kp2, des2 = orb.detectAndCompute(img2, None)
    return kp1, kp2, des1, des2

def calculate_matches(des1, des2):
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(des1, des2)
    matches = sorted(matches, key=lambda x: x.distance)
    return matches

def find_matching_coordinates(kp1, kp2, matches):
    coords1 = []
    coords2 = []
    for match in matches:
        img1_idx = match.queryIdx
        img2_idx = match.trainIdx
        (x1, y1) = kp1[img1_idx].pt
        (x2, y2) = kp2[img2_idx].pt
        coords1.append((x1, y1))
        coords2.append((x2, y2))
    return coords1, coords2

# --- FIM DA CAIXA NEGRA ---

# --- O VOSSO TRABALHO COMEÇA AQUI ---

def get_time_difference(image_1, image_2):
    # DESAFIO 1: Calcular o tempo entre fotos
    # Dica: Usem a biblioteca 'exif' para ler o 'datetime_original'
    pass # Apaguem isto e escrevam o código

def calculate_mean_distance(coords1, coords2):
    # DESAFIO 2: Calcular a distância média em píxeis
    # Dica: Usem math.hypot(x2-x1, y2-y1) para cada ponto
    pass # Apaguem isto e escrevam o código

def calculate_speed_in_kmps(feature_distance, GSD, time_difference):
    # DESAFIO 3: Calcular a velocidade final
    # Distancia (km) = (distancia_pixeis * GSD) / 100000
    # Velocidade = Distancia / Tempo
    pass # Apaguem isto e escrevam o código

# --- Execução Principal ---
if __name__ == "__main__":
    # --- PASSO 0: Capturar as Imagens ---
    # No Astro Pi Replay Tool, isto simula tirar fotos
    cam = Camera()
    
    img1 = 'foto_1.jpg'
    img2 = 'foto_2.jpg'
    
    print("A capturar Imagem 1...")
    cam.take_photo(img1)
    
    print("A aguardar 5 segundos...")
    sleep(5)
    
    print("A capturar Imagem 2...")
    cam.take_photo(img2)
    
    # Valor Mágico (cm por pixel)
    GSD = 12648 

    print("--- A INICIAR CÁLCULO ---")

    # 1. Calcular Tempo (usando os metadados das fotos capturadas)
    time_diff = get_time_difference(img1, img2)
    
    # 2. Processar Imagens (Caixa Negra)
    img1_cv, img2_cv = convert_to_cv(img1, img2)
    kp1, kp2, des1, des2 = calculate_features(img1_cv, img2_cv)
    matches = calculate_matches(des1, des2)
    coords1, coords2 = find_matching_coordinates(kp1, kp2, matches)

    # 3. Calcular Distância
    avg_distance = calculate_mean_distance(coords1, coords2)

    # 4. Calcular Velocidade
    speed = calculate_speed_in_kmps(avg_distance, GSD, time_diff)

    print(f"Velocidade Calculada: {speed:.4f} km/s")

    # --- PASSO CRUCIAL: CRIAR O RESULT.TXT ---
    # A ESA exige um ficheiro com APENAS o número, 
    # formatado com 4 casas decimais.
    
    resultado_formatado = f"{speed:.4f}"
    
    with open("result.txt", "w") as ficheiro:
        ficheiro.write(resultado_formatado)
        
    print(f"Sucesso! Ficheiro 'result.txt' criado com: {resultado_formatado}")
</code></pre>
      </div>
    </section>

    <!-- Soluções (Spoilers) -->
    <section class="mb-12">
      <h2
        class="text-3xl font-bold text-white mb-6 border-b border-slate-700 pb-2"
      >
        3. As Soluções (Cliquem para Revelar)
      </h2>

      <!-- Desafio 1 -->
      <div class="mb-8 bg-slate-800 p-6 rounded-xl">
        <h3 class="text-xl font-bold text-cyan-400 mb-3">
          Desafio 1: Diferença de Tempo
        </h3>
        <div class="spoiler" onclick="this.classList.add('revealed')">
          <pre><code class="python">
def get_time(image_path):
    with open(image_path, 'rb') as image_file:
        img = Image(image_file)
        time_str = img.get("datetime_original")
        time = datetime.strptime(time_str, '%Y:%m:%d %H:%M:%S')
    return time

def get_time_difference(image_1, image_2):
    t1 = get_time(image_1)
    t2 = get_time(image_2)
    diff = t2 - t1
    return diff.total_seconds()
</code></pre>
        </div>
      </div>

      <!-- Desafio 2 -->
      <div class="mb-8 bg-slate-800 p-6 rounded-xl">
        <h3 class="text-xl font-bold text-cyan-400 mb-3">
          Desafio 2: Distância em Píxeis
        </h3>
        <div class="spoiler" onclick="this.classList.add('revealed')">
          <pre><code class="python">
def calculate_mean_distance(coords1, coords2):
    all_distances = 0
    merged = list(zip(coords1, coords2))
    
    for c1, c2 in merged:
        x_diff = c1[0] - c2[0]
        y_diff = c1[1] - c2[1]
        dist = math.hypot(x_diff, y_diff)
        all_distances += dist
        
    return all_distances / len(merged)
</code></pre>
        </div>
      </div>

      <!-- Desafio 3 -->
      <div class="mb-8 bg-slate-800 p-6 rounded-xl">
        <h3 class="text-xl font-bold text-cyan-400 mb-3">
          Desafio 3: Velocidade Final
        </h3>
        <div class="spoiler" onclick="this.classList.add('revealed')">
          <pre><code class="python">
def calculate_speed_in_kmps(feature_distance, GSD, time_difference):
    # GSD está em cm, dividimos por 100000 para ter km
    distance_km = (feature_distance * GSD) / 100000
    
    speed = distance_km / time_difference
    return speed
</code></pre>
        </div>
      </div>
    </section>

    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>
